"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models


class _WorkspaceEntityDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    description: str


class WorkspaceEntityDict(_WorkspaceEntityDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    last_opened_resource_id: typing.Optional[int]
    thumbnail: typing.Optional[str]
    gallery: typing.Sequence["WorkspaceImageDict"]
    user_id: typing.Optional[str]
    publicable: bool
    featured: bool
    license: typing.Optional[str]
    collaborators: typing.Sequence["WorkspaceCollaboratorDict"]
    storage: typing.Optional["VolumeStorageDict"]
    tags: typing.Sequence["TagDict"]
    resources: typing.Sequence["WorkspaceResourceEntityDict"]


class TWorkspaceEntity(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace item

    Attrs:
        id: The id of the WorkspaceEntity.
        name: Workspace name.
        description: Workspace description.
        timestamp_created: Date/time the Workspace is created
        timestamp_updated: Date/time the Workspace is last updated
        last_opened_resource_id: The workspace resource id the workspace is
            opened last with
        thumbnail: The thumbnail of the WorkspaceEntity.
        gallery: Gallery with images of the workspace
        user_id: Workspace keycloak user id, will be automatically be set to
            the logged in user
        publicable: Is this a public workspace? Default false
        featured: Is this a featured workspace? Default false
        license: Workspace license
        collaborators: Collaborators who work on the workspace
        storage: The storage of the WorkspaceEntity.
        tags: The tags of the WorkspaceEntity.
        resources: Resources of the workspace

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    description: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    last_opened_resource_id: typing.Optional[int]
    thumbnail: typing.Optional[str]
    gallery: typing.Sequence["TWorkspaceImage"]
    user_id: typing.Optional[str]
    publicable: bool
    featured: bool
    license: typing.Optional[str]
    collaborators: typing.Sequence["TWorkspaceCollaborator"]
    storage: typing.Optional["TVolumeStorage"]
    tags: typing.Sequence["TTag"]
    resources: typing.Sequence["TWorkspaceResourceEntity"]

    def __init__(
        self,
        name: str,
        description: str,
        id: typing.Optional[int] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        last_opened_resource_id: typing.Optional[int] = None,
        thumbnail: typing.Optional[str] = None,
        gallery: typing.Optional[typing.Sequence["TWorkspaceImage"]] = None,
        user_id: typing.Optional[str] = None,
        publicable: bool = False,
        featured: bool = False,
        license: typing.Optional[str] = None,
        collaborators: typing.Optional[
            typing.Sequence["TWorkspaceCollaborator"]
        ] = None,
        storage: typing.Optional["TVolumeStorage"] = None,
        tags: typing.Optional[typing.Sequence["TTag"]] = None,
        resources: typing.Optional[typing.Sequence["TWorkspaceResourceEntity"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceEntity.
            name: Workspace name.
            description: Workspace description.
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            last_opened_resource_id: The workspace resource id the workspace is
                opened last with
            thumbnail: The thumbnail of the WorkspaceEntity.
            gallery: Gallery with images of the workspace
            user_id: Workspace keycloak user id, will be automatically be set
                to the logged in user
            publicable: Is this a public workspace? Default false
            featured: Is this a featured workspace? Default false
            license: Workspace license
            collaborators: Collaborators who work on the workspace
            storage: The storage of the WorkspaceEntity.
            tags: The tags of the WorkspaceEntity.
            resources: Resources of the workspace

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        description: str,
        id: typing.Optional[int] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        last_opened_resource_id: typing.Optional[int] = None,
        thumbnail: typing.Optional[str] = None,
        gallery: typing.Optional[typing.Sequence["WorkspaceImageDict"]] = None,
        user_id: typing.Optional[str] = None,
        publicable: bool = False,
        featured: bool = False,
        license: typing.Optional[str] = None,
        collaborators: typing.Optional[
            typing.Sequence["WorkspaceCollaboratorDict"]
        ] = None,
        storage: typing.Optional["VolumeStorageDict"] = None,
        tags: typing.Optional[typing.Sequence["TagDict"]] = None,
        resources: typing.Optional[
            typing.Sequence["WorkspaceResourceEntityDict"]
        ] = None,
    ) -> "TWorkspaceEntity":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceEntity.
            name: Workspace name.
            description: Workspace description.
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            last_opened_resource_id: The workspace resource id the workspace is
                opened last with
            thumbnail: The thumbnail of the WorkspaceEntity.
            gallery: Gallery with images of the workspace
            user_id: Workspace keycloak user id, will be automatically be set
                to the logged in user
            publicable: Is this a public workspace? Default false
            featured: Is this a featured workspace? Default false
            license: Workspace license
            collaborators: Collaborators who work on the workspace
            storage: The storage of the WorkspaceEntity.
            tags: The tags of the WorkspaceEntity.
            resources: Resources of the workspace

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceEntity":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceEntityDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceEntity: TWorkspaceEntity = models.WorkspaceEntity  # type: ignore


class _WorkspaceCollaboratorDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    user_id: str


class WorkspaceCollaboratorDict(_WorkspaceCollaboratorDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TWorkspaceCollaborator(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace Collaborator of a workspace

    Attrs:
        id: The id of the WorkspaceCollaborator.
        user_id: Workspace Collaborator keycloak user id

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    user_id: str

    def __init__(self, user_id: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceCollaborator.
            user_id: Workspace Collaborator keycloak user id

        """
        ...

    @classmethod
    def from_dict(
        cls, user_id: str, id: typing.Optional[int] = None
    ) -> "TWorkspaceCollaborator":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceCollaborator.
            user_id: Workspace Collaborator keycloak user id

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceCollaborator":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceCollaboratorDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceCollaborator: TWorkspaceCollaborator = models.WorkspaceCollaborator  # type: ignore


class _WorkspaceImageDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    image: str


class WorkspaceImageDict(_WorkspaceImageDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TWorkspaceImage(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Workspace images of a workspace

    Attrs:
        id: The id of the WorkspaceImage.
        image: The image of the WorkspaceImage.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    image: str

    def __init__(self, image: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceImage.
            image: The image of the WorkspaceImage.

        """
        ...

    @classmethod
    def from_dict(
        cls, image: str, id: typing.Optional[int] = None
    ) -> "TWorkspaceImage":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceImage.
            image: The image of the WorkspaceImage.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceImage":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceImageDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceImage: TWorkspaceImage = models.WorkspaceImage  # type: ignore


class _WorkspaceResourceEntityDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    resource_type: str


class WorkspaceResourceEntityDict(_WorkspaceResourceEntityDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    folder: typing.Optional[str]
    status: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    timestamp_last_opened: typing.Optional[datetime.datetime]
    origin: typing.Optional[str]
    workspace_id: typing.Optional[int]


class TWorkspaceResourceEntity(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the WorkspaceResourceEntity.
        name: WorkspaceResource name
        folder: WorkspaceResource folder where the resource will stored in the
            pvc
        status: Resource status:  * a - Available  * e - Error, not available
            * p - Pending
        timestamp_created: Date/time of creation of the WorkspaceResource
        timestamp_updated: Date/time of last updating of the WorkspaceResource
        timestamp_last_opened: Date/time of last opening of the
            WorkspaceResource
        resource_type: Resource type:  * e - Experimental  * m - Model  * g -
            Generic  * u - Unknown (to be defined)
        origin: Origin data JSON formatted of the WorkspaceResource
        workspace_id: workspace_id

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    folder: typing.Optional[str]
    status: str
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    timestamp_last_opened: typing.Optional[datetime.datetime]
    resource_type: str
    origin: typing.Optional[str]
    workspace_id: typing.Optional[int]

    def __init__(
        self,
        name: str,
        resource_type: str,
        id: typing.Optional[int] = None,
        folder: typing.Optional[str] = None,
        status: str = "p",
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        timestamp_last_opened: typing.Optional[datetime.datetime] = None,
        origin: typing.Optional[str] = None,
        workspace_id: typing.Optional[int] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the WorkspaceResourceEntity.
            name: WorkspaceResource name
            folder: WorkspaceResource folder where the resource will stored in
                the pvc
            status: Resource status:  * a - Available  * e - Error, not
                available  * p - Pending
            timestamp_created: Date/time of creation of the WorkspaceResource
            timestamp_updated: Date/time of last updating of the
                WorkspaceResource
            timestamp_last_opened: Date/time of last opening of the
                WorkspaceResource
            resource_type: Resource type:  * e - Experimental  * m - Model  * g
                - Generic  * u - Unknown (to be defined)
            origin: Origin data JSON formatted of the WorkspaceResource
            workspace_id: workspace_id

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        resource_type: str,
        id: typing.Optional[int] = None,
        folder: typing.Optional[str] = None,
        status: str = "p",
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        timestamp_last_opened: typing.Optional[datetime.datetime] = None,
        origin: typing.Optional[str] = None,
        workspace_id: typing.Optional[int] = None,
    ) -> "TWorkspaceResourceEntity":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the WorkspaceResourceEntity.
            name: WorkspaceResource name
            folder: WorkspaceResource folder where the resource will stored in
                the pvc
            status: Resource status:  * a - Available  * e - Error, not
                available  * p - Pending
            timestamp_created: Date/time of creation of the WorkspaceResource
            timestamp_updated: Date/time of last updating of the
                WorkspaceResource
            timestamp_last_opened: Date/time of last opening of the
                WorkspaceResource
            resource_type: Resource type:  * e - Experimental  * m - Model  * g
                - Generic  * u - Unknown (to be defined)
            origin: Origin data JSON formatted of the WorkspaceResource
            workspace_id: workspace_id

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TWorkspaceResourceEntity":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> WorkspaceResourceEntityDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


WorkspaceResourceEntity: TWorkspaceResourceEntity = models.WorkspaceResourceEntity  # type: ignore


class _VolumeStorageDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class VolumeStorageDict(_VolumeStorageDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TVolumeStorage(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Volume which can be connected to a workspace

    Attrs:
        id: The id of the VolumeStorage.
        name: StorageVolume name

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str

    def __init__(self, name: str, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the VolumeStorage.
            name: StorageVolume name

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None) -> "TVolumeStorage":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the VolumeStorage.
            name: StorageVolume name

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TVolumeStorage":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> VolumeStorageDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


VolumeStorage: TVolumeStorage = models.VolumeStorage  # type: ignore


class _OSBRepositoryEntityDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    repository_type: str
    content_types: str
    uri: str


class OSBRepositoryEntityDict(_OSBRepositoryEntityDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    summary: typing.Optional[str]
    auto_sync: bool
    default_context: typing.Optional[str]
    user_id: typing.Optional[str]
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    tags: typing.Sequence["TagDict"]


class TOSBRepositoryEntity(typing.Protocol):
    """
    SQLAlchemy model protocol.

    OSB Repository Base model

    Attrs:
        id: The id of the OSBRepositoryEntity.
        name: Repository name.
        summary: Summary describing the OSB Repository
        repository_type: Repository type:   * dandi - DANDI repository   *
            figshare - FigShare repository   * github - Github repository
        content_types: List of Repository Content Types
        auto_sync: Auto sync of the resources
        uri: URI of the repository
        default_context: The default branch to show for this repository
        user_id: OSBRepository keycloak user id, will be automatically be set
            to the logged in user
        timestamp_created: Date/time the Workspace is created
        timestamp_updated: Date/time the Workspace is last updated
        tags: The tags of the OSBRepositoryEntity.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    name: str
    summary: typing.Optional[str]
    repository_type: str
    content_types: str
    auto_sync: bool
    uri: str
    default_context: typing.Optional[str]
    user_id: typing.Optional[str]
    timestamp_created: typing.Optional[datetime.datetime]
    timestamp_updated: typing.Optional[datetime.datetime]
    tags: typing.Sequence["TTag"]

    def __init__(
        self,
        name: str,
        repository_type: str,
        content_types: str,
        uri: str,
        id: typing.Optional[int] = None,
        summary: typing.Optional[str] = None,
        auto_sync: bool = True,
        default_context: typing.Optional[str] = None,
        user_id: typing.Optional[str] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        tags: typing.Optional[typing.Sequence["TTag"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the OSBRepositoryEntity.
            name: Repository name.
            summary: Summary describing the OSB Repository
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            content_types: List of Repository Content Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            default_context: The default branch to show for this repository
            user_id: OSBRepository keycloak user id, will be automatically be
                set to the logged in user
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            tags: The tags of the OSBRepositoryEntity.

        """
        ...

    @classmethod
    def from_dict(
        cls,
        name: str,
        repository_type: str,
        content_types: str,
        uri: str,
        id: typing.Optional[int] = None,
        summary: typing.Optional[str] = None,
        auto_sync: bool = True,
        default_context: typing.Optional[str] = None,
        user_id: typing.Optional[str] = None,
        timestamp_created: typing.Optional[datetime.datetime] = None,
        timestamp_updated: typing.Optional[datetime.datetime] = None,
        tags: typing.Optional[typing.Sequence["TagDict"]] = None,
    ) -> "TOSBRepositoryEntity":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the OSBRepositoryEntity.
            name: Repository name.
            summary: Summary describing the OSB Repository
            repository_type: Repository type:   * dandi - DANDI repository   *
                figshare - FigShare repository   * github - Github repository
            content_types: List of Repository Content Types
            auto_sync: Auto sync of the resources
            uri: URI of the repository
            default_context: The default branch to show for this repository
            user_id: OSBRepository keycloak user id, will be automatically be
                set to the logged in user
            timestamp_created: Date/time the Workspace is created
            timestamp_updated: Date/time the Workspace is last updated
            tags: The tags of the OSBRepositoryEntity.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TOSBRepositoryEntity":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> OSBRepositoryEntityDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


OSBRepositoryEntity: TOSBRepositoryEntity = models.OSBRepositoryEntity  # type: ignore


class TagDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    tag: typing.Optional[str]


class TTag(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Tags

    Attrs:
        id: The id of the Tag.
        tag: The tag of the Tag.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: int
    tag: typing.Optional[str]

    def __init__(
        self, id: typing.Optional[int] = None, tag: typing.Optional[str] = None
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Tag.
            tag: The tag of the Tag.

        """
        ...

    @classmethod
    def from_dict(
        cls, id: typing.Optional[int] = None, tag: typing.Optional[str] = None
    ) -> "TTag":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Tag.
            tag: The tag of the Tag.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TTag":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> TagDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Tag: TTag = models.Tag  # type: ignore
