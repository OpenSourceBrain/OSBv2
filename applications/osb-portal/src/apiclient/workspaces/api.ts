// tslint:disable
/**
 * Workspaces manager API
 * Opensource Brain Platform - Reference Workspaces manager API
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Figshare repository
 * @export
 * @interface FigshareRepository
 */
export interface FigshareRepository {
    /**
     * 
     * @type {number}
     * @memberof FigshareRepository
     */
    id?: number;
    /**
     * URL of the figshare repository
     * @type {string}
     * @memberof FigshareRepository
     */
    url: string;
}
/**
 * GIT repository
 * @export
 * @interface GITRepository
 */
export interface GITRepository {
    /**
     * 
     * @type {number}
     * @memberof GITRepository
     */
    id?: number;
    /**
     * Public key of the git repository
     * @type {string}
     * @memberof GITRepository
     */
    public_key: string;
    /**
     * Public key of the git repository
     * @type {string}
     * @memberof GITRepository
     */
    private_key: string;
    /**
     * URL of the git repository
     * @type {string}
     * @memberof GITRepository
     */
    url: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {any}
     * @memberof InlineObject
     */
    thumbNail?: any;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {any}
     * @memberof InlineObject1
     */
    image?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse200
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Workspace>}
     * @memberof InlineResponse200
     */
    workspaces?: Array<Workspace>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2001
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<OSBRepository>}
     * @memberof InlineResponse2001
     */
    osbrepositories?: Array<OSBRepository>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2002
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<GITRepository>}
     * @memberof InlineResponse2002
     */
    gitrepositories?: Array<GITRepository>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2003
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<FigshareRepository>}
     * @memberof InlineResponse2003
     */
    figsharerepositories?: Array<FigshareRepository>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2004
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<VolumeStorage>}
     * @memberof InlineResponse2004
     */
    volumestorages?: Array<VolumeStorage>;
}
/**
 * Opensource brain repository
 * @export
 * @interface OSBRepository
 */
export interface OSBRepository {
    /**
     * 
     * @type {number}
     * @memberof OSBRepository
     */
    id?: number;
    /**
     * Universally unique identifier of the OSB repository
     * @type {string}
     * @memberof OSBRepository
     */
    uuid: string;
    /**
     * OSB repository name
     * @type {string}
     * @memberof OSBRepository
     */
    name: string;
    /**
     * 
     * @type {VolumeStorage}
     * @memberof OSBRepository
     */
    storage: VolumeStorage;
    /**
     * 
     * @type {Array<WorkspaceResource>}
     * @memberof OSBRepository
     */
    resources?: Array<WorkspaceResource>;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    current_page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    number_of_pages?: number;
}
/**
 * Resource status:   * a - Available   * e - Error, not available   * p - Pending 
 * @export
 * @enum {string}
 */
export enum ResourceStatus {
    A = 'a',
    E = 'e',
    P = 'p'
}

/**
 * Resource type:  * e - Experimental  * m - Model  * g - Generic 
 * @export
 * @enum {string}
 */
export enum ResourceType {
    E = 'e',
    M = 'm',
    G = 'g'
}

/**
 * key cloak User
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Keycloak user id
     * @type {string}
     * @memberof User
     */
    keycloak_id?: string;
    /**
     * First name of the user (derived from Keycload)
     * @type {string}
     * @memberof User
     */
    firstname?: string;
    /**
     * Last name of the user (derived from Keycload)
     * @type {string}
     * @memberof User
     */
    lastname?: string;
    /**
     * Email address of the user (derived from Keycloak)
     * @type {string}
     * @memberof User
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Valid
 */
export interface Valid {
    /**
     * 
     * @type {string}
     * @memberof Valid
     */
    response?: string;
}
/**
 * Volume which can be connected to a workspace
 * @export
 * @interface VolumeStorage
 */
export interface VolumeStorage {
    /**
     * 
     * @type {number}
     * @memberof VolumeStorage
     */
    id?: number;
    /**
     * StorageVolume name
     * @type {string}
     * @memberof VolumeStorage
     */
    name: string;
}
/**
 * Workspace item
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {number}
     * @memberof Workspace
     */
    id?: number;
    /**
     * Workspace name.
     * @type {string}
     * @memberof Workspace
     */
    name: string;
    /**
     * Workspace description.
     * @type {string}
     * @memberof Workspace
     */
    description: string;
    /**
     * Date/time the Workspace is created
     * @type {string}
     * @memberof Workspace
     */
    timestamp_created?: string;
    /**
     * Date/time the Workspace is last updated
     * @type {string}
     * @memberof Workspace
     */
    timestamp_updated?: string;
    /**
     * Workspace tags
     * @type {Array<WorkspaceTag>}
     * @memberof Workspace
     */
    tags?: Array<WorkspaceTag>;
    /**
     * The workspace resource id the workspace is opened last with
     * @type {number}
     * @memberof Workspace
     */
    last_opened_resource_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    thumbnail?: string;
    /**
     * Gallery with images of the workspace
     * @type {Array<WorkspaceImage>}
     * @memberof Workspace
     */
    gallery?: Array<WorkspaceImage>;
    /**
     * 
     * @type {User}
     * @memberof Workspace
     */
    owner?: User;
    /**
     * Is the workspace available for non collaborators? Default false
     * @type {boolean}
     * @memberof Workspace
     */
    publicable?: boolean;
    /**
     * Workspace license
     * @type {string}
     * @memberof Workspace
     */
    license?: string;
    /**
     * Collaborators who work on the workspace
     * @type {Array<User>}
     * @memberof Workspace
     */
    collaborators?: Array<User>;
    /**
     * Resources of the workspace
     * @type {Array<WorkspaceResource>}
     * @memberof Workspace
     */
    resources?: Array<WorkspaceResource>;
    /**
     * 
     * @type {VolumeStorage}
     * @memberof Workspace
     */
    storage?: VolumeStorage;
}
/**
 * Workspace images of a workspace
 * @export
 * @interface WorkspaceImage
 */
export interface WorkspaceImage {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceImage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceImage
     */
    image: string;
}
/**
 * Workspace Resource item of a Workspace
 * @export
 * @interface WorkspaceResource
 */
export interface WorkspaceResource {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceResource
     */
    id?: number;
    /**
     * WorkspaceResource name
     * @type {string}
     * @memberof WorkspaceResource
     */
    name: string;
    /**
     * WorkspaceResource location original location of the resource
     * @type {string}
     * @memberof WorkspaceResource
     */
    location: string;
    /**
     * WorkspaceResource folder where the resource will stored in the pvc
     * @type {string}
     * @memberof WorkspaceResource
     */
    folder?: string;
    /**
     * 
     * @type {ResourceStatus}
     * @memberof WorkspaceResource
     */
    status?: ResourceStatus;
    /**
     * Date/time of creation of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_created?: string;
    /**
     * Date/time of last updating of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_updated?: string;
    /**
     * Date/time of last opening of the WorkspaceResource
     * @type {string}
     * @memberof WorkspaceResource
     */
    timestamp_last_opened?: string;
    /**
     * 
     * @type {ResourceType}
     * @memberof WorkspaceResource
     */
    resource_type: ResourceType;
    /**
     * The id of the Workspace this Workspace Resource belongs to
     * @type {number}
     * @memberof WorkspaceResource
     */
    workspace_id: number;
}
/**
 * Workspace tags linking to workspaces
 * @export
 * @interface WorkspaceTag
 */
export interface WorkspaceTag {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceTag
     */
    id?: number;
    /**
     * WorkspaceTag tag
     * @type {string}
     * @memberof WorkspaceTag
     */
    tag: string;
}

/**
 * RestApi - axios parameter creator
 * @export
 */
export const RestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Used to list all available figsharerepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/figsharerepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling figsharerepositoryIdDelete.');
            }
            const localVarPath = `/figsharerepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling figsharerepositoryIdGet.');
            }
            const localVarPath = `/figsharerepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an figsharerepository in the repository.
         * @param {number} id 
         * @param {FigshareRepository} figshareRepository The figsharerepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdPut: async (id: number, figshareRepository: FigshareRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling figsharerepositoryIdPut.');
            }
            // verify required parameter 'figshareRepository' is not null or undefined
            if (figshareRepository === null || figshareRepository === undefined) {
                throw new RequiredError('figshareRepository','Required parameter figshareRepository was null or undefined when calling figsharerepositoryIdPut.');
            }
            const localVarPath = `/figsharerepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof figshareRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(figshareRepository !== undefined ? figshareRepository : {}) : (figshareRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
         * @param {FigshareRepository} figshareRepository The FigshareRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryPost: async (figshareRepository: FigshareRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'figshareRepository' is not null or undefined
            if (figshareRepository === null || figshareRepository === undefined) {
                throw new RequiredError('figshareRepository','Required parameter figshareRepository was null or undefined when calling figsharerepositoryPost.');
            }
            const localVarPath = `/figsharerepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof figshareRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(figshareRepository !== undefined ? figshareRepository : {}) : (figshareRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available gitrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/gitrepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gitrepositoryIdDelete.');
            }
            const localVarPath = `/gitrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gitrepositoryIdGet.');
            }
            const localVarPath = `/gitrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a gitrepository in the repository.
         * @param {number} id 
         * @param {GITRepository} gITRepository The gitrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdPut: async (id: number, gITRepository: GITRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gitrepositoryIdPut.');
            }
            // verify required parameter 'gITRepository' is not null or undefined
            if (gITRepository === null || gITRepository === undefined) {
                throw new RequiredError('gITRepository','Required parameter gITRepository was null or undefined when calling gitrepositoryIdPut.');
            }
            const localVarPath = `/gitrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof gITRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(gITRepository !== undefined ? gITRepository : {}) : (gITRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
         * @param {GITRepository} gITRepository The GITRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryPost: async (gITRepository: GITRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gITRepository' is not null or undefined
            if (gITRepository === null || gITRepository === undefined) {
                throw new RequiredError('gITRepository','Required parameter gITRepository was null or undefined when calling gitrepositoryPost.');
            }
            const localVarPath = `/gitrepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof gITRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(gITRepository !== undefined ? gITRepository : {}) : (gITRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available osbrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/osbrepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling osbrepositoryIdDelete.');
            }
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling osbrepositoryIdGet.');
            }
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an osbrepository in the repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The osbrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdPut: async (id: number, oSBRepository: OSBRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling osbrepositoryIdPut.');
            }
            // verify required parameter 'oSBRepository' is not null or undefined
            if (oSBRepository === null || oSBRepository === undefined) {
                throw new RequiredError('oSBRepository','Required parameter oSBRepository was null or undefined when calling osbrepositoryIdPut.');
            }
            const localVarPath = `/osbrepository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof oSBRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(oSBRepository !== undefined ? oSBRepository : {}) : (oSBRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSBRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryPost: async (oSBRepository: OSBRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oSBRepository' is not null or undefined
            if (oSBRepository === null || oSBRepository === undefined) {
                throw new RequiredError('oSBRepository','Required parameter oSBRepository was null or undefined when calling osbrepositoryPost.');
            }
            const localVarPath = `/osbrepository`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof oSBRepository !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(oSBRepository !== undefined ? oSBRepository : {}) : (oSBRepository || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volumestorage`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling volumestorageIdDelete.');
            }
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling volumestorageIdGet.');
            }
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdPut: async (id: number, volumeStorage: VolumeStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling volumestorageIdPut.');
            }
            // verify required parameter 'volumeStorage' is not null or undefined
            if (volumeStorage === null || volumeStorage === undefined) {
                throw new RequiredError('volumeStorage','Required parameter volumeStorage was null or undefined when calling volumestorageIdPut.');
            }
            const localVarPath = `/volumestorage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof volumeStorage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(volumeStorage !== undefined ? volumeStorage : {}) : (volumeStorage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestoragePost: async (volumeStorage: VolumeStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'volumeStorage' is not null or undefined
            if (volumeStorage === null || volumeStorage === undefined) {
                throw new RequiredError('volumeStorage','Required parameter volumeStorage was null or undefined when calling volumestoragePost.');
            }
            const localVarPath = `/volumestorage`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof volumeStorage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(volumeStorage !== undefined ? volumeStorage : {}) : (volumeStorage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39;. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGet: async (page?: number, perPage?: number, q?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspace`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceIdDelete.');
            }
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceIdGet.');
            }
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdPut: async (id: number, workspace: Workspace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceIdPut.');
            }
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceIdPut.');
            }
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workspace !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workspace !== undefined ? workspace : {}) : (workspace || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The owner will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePost: async (workspace: Workspace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspacePost.');
            }
            const localVarPath = `/workspace`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workspace !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workspace !== undefined ? workspace : {}) : (workspace || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceresourceIdDelete.');
            }
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceresourceIdGet.');
            }
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdPut: async (id: number, workspaceResource: WorkspaceResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspaceresourceIdPut.');
            }
            // verify required parameter 'workspaceResource' is not null or undefined
            if (workspaceResource === null || workspaceResource === undefined) {
                throw new RequiredError('workspaceResource','Required parameter workspaceResource was null or undefined when calling workspaceresourceIdPut.');
            }
            const localVarPath = `/workspaceresource/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workspaceResource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workspaceResource !== undefined ? workspaceResource : {}) : (workspaceResource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourcePost: async (workspaceResource: WorkspaceResource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceResource' is not null or undefined
            if (workspaceResource === null || workspaceResource === undefined) {
                throw new RequiredError('workspaceResource','Required parameter workspaceResource was null or undefined when calling workspaceresourcePost.');
            }
            const localVarPath = `/workspaceresource`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workspaceResource !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workspaceResource !== undefined ? workspaceResource : {}) : (workspaceResource || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceAddimage: async (id: number, image?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspacesControllerWorkspaceAddimage.');
            }
            const localVarPath = `/workspace/{id}/gallery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceDelimage: async (id: number, imageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspacesControllerWorkspaceDelimage.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling workspacesControllerWorkspaceDelimage.');
            }
            const localVarPath = `/workspace/{id}/gallery/{image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceResourceOpen: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspacesControllerWorkspaceResourceOpen.');
            }
            const localVarPath = `/workspaceresource/{id}/open`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceSetthumbnail: async (id: number, thumbNail?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling workspacesControllerWorkspaceSetthumbnail.');
            }
            const localVarPath = `/workspace/{id}/thumbnail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (thumbNail !== undefined) { 
                localVarFormParams.append('thumbNail', thumbNail as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestApi - functional programming interface
 * @export
 */
export const RestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Used to list all available figsharerepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async figsharerepositoryGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).figsharerepositoryGet(page, perPage, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async figsharerepositoryIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).figsharerepositoryIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async figsharerepositoryIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FigshareRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).figsharerepositoryIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an figsharerepository in the repository.
         * @param {number} id 
         * @param {FigshareRepository} figshareRepository The figsharerepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async figsharerepositoryIdPut(id: number, figshareRepository: FigshareRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FigshareRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).figsharerepositoryIdPut(id, figshareRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
         * @param {FigshareRepository} figshareRepository The FigshareRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async figsharerepositoryPost(figshareRepository: FigshareRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FigshareRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).figsharerepositoryPost(figshareRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to list all available gitrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitrepositoryGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).gitrepositoryGet(page, perPage, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitrepositoryIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).gitrepositoryIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitrepositoryIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GITRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).gitrepositoryIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a gitrepository in the repository.
         * @param {number} id 
         * @param {GITRepository} gITRepository The gitrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitrepositoryIdPut(id: number, gITRepository: GITRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GITRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).gitrepositoryIdPut(id, gITRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
         * @param {GITRepository} gITRepository The GITRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitrepositoryPost(gITRepository: GITRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GITRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).gitrepositoryPost(gITRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to list all available osbrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).osbrepositoryGet(page, perPage, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).osbrepositoryIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).osbrepositoryIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an osbrepository in the repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The osbrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).osbrepositoryIdPut(id, oSBRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSBRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osbrepositoryPost(oSBRepository: OSBRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OSBRepository>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).osbrepositoryPost(oSBRepository, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).volumestorageGet(page, perPage, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).volumestorageIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).volumestorageIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).volumestorageIdPut(id, volumeStorage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumestoragePost(volumeStorage: VolumeStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeStorage>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).volumestoragePost(volumeStorage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39;. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceGet(page?: number, perPage?: number, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceGet(page, perPage, q, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceIdPut(id: number, workspace: Workspace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceIdPut(id, workspace, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The owner will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacePost(workspace: Workspace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspacePost(workspace, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceresourceIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceresourceIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceresourceIdPut(id, workspaceResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResource>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspaceresourcePost(workspaceResource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerWorkspaceAddimage(id: number, image?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspacesControllerWorkspaceAddimage(id, image, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerWorkspaceDelimage(id: number, imageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspacesControllerWorkspaceDelimage(id, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerWorkspaceResourceOpen(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspacesControllerWorkspaceResourceOpen(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerWorkspaceSetthumbnail(id: number, thumbNail?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RestApiAxiosParamCreator(configuration).workspacesControllerWorkspaceSetthumbnail(id, thumbNail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RestApi - factory interface
 * @export
 */
export const RestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Used to list all available figsharerepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return RestApiFp(configuration).figsharerepositoryGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).figsharerepositoryIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve an figsharerepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdGet(id: number, options?: any): AxiosPromise<FigshareRepository> {
            return RestApiFp(configuration).figsharerepositoryIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an figsharerepository in the repository.
         * @param {number} id 
         * @param {FigshareRepository} figshareRepository The figsharerepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryIdPut(id: number, figshareRepository: FigshareRepository, options?: any): AxiosPromise<FigshareRepository> {
            return RestApiFp(configuration).figsharerepositoryIdPut(id, figshareRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
         * @param {FigshareRepository} figshareRepository The FigshareRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        figsharerepositoryPost(figshareRepository: FigshareRepository, options?: any): AxiosPromise<FigshareRepository> {
            return RestApiFp(configuration).figsharerepositoryPost(figshareRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available gitrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return RestApiFp(configuration).gitrepositoryGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).gitrepositoryIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a gitrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdGet(id: number, options?: any): AxiosPromise<GITRepository> {
            return RestApiFp(configuration).gitrepositoryIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a gitrepository in the repository.
         * @param {number} id 
         * @param {GITRepository} gITRepository The gitrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryIdPut(id: number, gITRepository: GITRepository, options?: any): AxiosPromise<GITRepository> {
            return RestApiFp(configuration).gitrepositoryIdPut(id, gITRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
         * @param {GITRepository} gITRepository The GITRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitrepositoryPost(gITRepository: GITRepository, options?: any): AxiosPromise<GITRepository> {
            return RestApiFp(configuration).gitrepositoryPost(gITRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available osbrepositories.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return RestApiFp(configuration).osbrepositoryGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).osbrepositoryIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve an osbrepository from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdGet(id: number, options?: any): AxiosPromise<OSBRepository> {
            return RestApiFp(configuration).osbrepositoryIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an osbrepository in the repository.
         * @param {number} id 
         * @param {OSBRepository} oSBRepository The osbrepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, options?: any): AxiosPromise<OSBRepository> {
            return RestApiFp(configuration).osbrepositoryIdPut(id, oSBRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
         * @param {OSBRepository} oSBRepository The OSBRepository to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osbrepositoryPost(oSBRepository: OSBRepository, options?: any): AxiosPromise<OSBRepository> {
            return RestApiFp(configuration).osbrepositoryPost(oSBRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available volumestorages.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return RestApiFp(configuration).volumestorageGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).volumestorageIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve an volumestorage from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdGet(id: number, options?: any): AxiosPromise<VolumeStorage> {
            return RestApiFp(configuration).volumestorageIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an volumestorage in the repository.
         * @param {number} id 
         * @param {VolumeStorage} volumeStorage The volumestorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any): AxiosPromise<VolumeStorage> {
            return RestApiFp(configuration).volumestorageIdPut(id, volumeStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
         * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumestoragePost(volumeStorage: VolumeStorage, options?: any): AxiosPromise<VolumeStorage> {
            return RestApiFp(configuration).volumestoragePost(volumeStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to list all available workspaces.
         * @param {number} [page] The page number for starting to collect the result set.
         * @param {number} [perPage] The number of items to return.
         * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39;. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceGet(page?: number, perPage?: number, q?: string, options?: any): AxiosPromise<InlineResponse200> {
            return RestApiFp(configuration).workspaceGet(page, perPage, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspaceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a workspace from the repository.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdGet(id: number, options?: any): AxiosPromise<Workspace> {
            return RestApiFp(configuration).workspaceIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace in the repository.
         * @param {number} id 
         * @param {Workspace} workspace The workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceIdPut(id: number, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return RestApiFp(configuration).workspaceIdPut(id, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a Workspace to the repository. The owner will be automatically filled with the current user
         * @param {Workspace} workspace The Workspace to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacePost(workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return RestApiFp(configuration).workspacePost(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdDelete(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspaceresourceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to retrieve a WorkspaceResource.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdGet(id: number, options?: any): AxiosPromise<WorkspaceResource> {
            return RestApiFp(configuration).workspaceresourceIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the WorkspaceResource.
         * @param {number} id 
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any): AxiosPromise<WorkspaceResource> {
            return RestApiFp(configuration).workspaceresourceIdPut(id, workspaceResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to save a WorkspaceResource to the repository.
         * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any): AxiosPromise<WorkspaceResource> {
            return RestApiFp(configuration).workspaceresourcePost(workspaceResource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds and image to the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceAddimage(id: number, image?: any, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspacesControllerWorkspaceAddimage(id, image, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workspace Image from the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {number} imageId Workspace Image Id to be deleted from the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceDelimage(id: number, imageId: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspacesControllerWorkspaceDelimage(id, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
         * @param {number} id WorkspaceResource ID of the WorkspaceResource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceResourceOpen(id: number, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspacesControllerWorkspaceResourceOpen(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the thumbnail of the workspace.
         * @param {number} id Workspace ID of the workspace
         * @param {any} [thumbNail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerWorkspaceSetthumbnail(id: number, thumbNail?: any, options?: any): AxiosPromise<void> {
            return RestApiFp(configuration).workspacesControllerWorkspaceSetthumbnail(id, thumbNail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestApi - object-oriented interface
 * @export
 * @class RestApi
 * @extends {BaseAPI}
 */
export class RestApi extends BaseAPI {
    /**
     * 
     * @summary Used to list all available figsharerepositories.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public figsharerepositoryGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).figsharerepositoryGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an figsharerepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public figsharerepositoryIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).figsharerepositoryIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve an figsharerepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public figsharerepositoryIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).figsharerepositoryIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an figsharerepository in the repository.
     * @param {number} id 
     * @param {FigshareRepository} figshareRepository The figsharerepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public figsharerepositoryIdPut(id: number, figshareRepository: FigshareRepository, options?: any) {
        return RestApiFp(this.configuration).figsharerepositoryIdPut(id, figshareRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
     * @param {FigshareRepository} figshareRepository The FigshareRepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public figsharerepositoryPost(figshareRepository: FigshareRepository, options?: any) {
        return RestApiFp(this.configuration).figsharerepositoryPost(figshareRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available gitrepositories.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public gitrepositoryGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).gitrepositoryGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a gitrepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public gitrepositoryIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).gitrepositoryIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a gitrepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public gitrepositoryIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).gitrepositoryIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a gitrepository in the repository.
     * @param {number} id 
     * @param {GITRepository} gITRepository The gitrepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public gitrepositoryIdPut(id: number, gITRepository: GITRepository, options?: any) {
        return RestApiFp(this.configuration).gitrepositoryIdPut(id, gITRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
     * @param {GITRepository} gITRepository The GITRepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public gitrepositoryPost(gITRepository: GITRepository, options?: any) {
        return RestApiFp(this.configuration).gitrepositoryPost(gITRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available osbrepositories.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an osbrepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve an osbrepository from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an osbrepository in the repository.
     * @param {number} id 
     * @param {OSBRepository} oSBRepository The osbrepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryIdPut(id: number, oSBRepository: OSBRepository, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryIdPut(id, oSBRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
     * @param {OSBRepository} oSBRepository The OSBRepository to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public osbrepositoryPost(oSBRepository: OSBRepository, options?: any) {
        return RestApiFp(this.configuration).osbrepositoryPost(oSBRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available volumestorages.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).volumestorageGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an volumestorage from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve an volumestorage from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an volumestorage in the repository.
     * @param {number} id 
     * @param {VolumeStorage} volumeStorage The volumestorage to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestorageIdPut(id: number, volumeStorage: VolumeStorage, options?: any) {
        return RestApiFp(this.configuration).volumestorageIdPut(id, volumeStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
     * @param {VolumeStorage} volumeStorage The VolumeStorage to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public volumestoragePost(volumeStorage: VolumeStorage, options?: any) {
        return RestApiFp(this.configuration).volumestoragePost(volumeStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to list all available workspaces.
     * @param {number} [page] The page number for starting to collect the result set.
     * @param {number} [perPage] The number of items to return.
     * @param {string} [q] The search string for filtering of the items to return. Multiple criteria are seperated by \&#39;+\&#39;. Format [fieldname][comparator &#x3D; , __not&#x3D; , __like&#x3D; ][value]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceGet(page?: number, perPage?: number, q?: string, options?: any) {
        return RestApiFp(this.configuration).workspaceGet(page, perPage, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a workspace from the repository.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace in the repository.
     * @param {number} id 
     * @param {Workspace} workspace The workspace to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceIdPut(id: number, workspace: Workspace, options?: any) {
        return RestApiFp(this.configuration).workspaceIdPut(id, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a Workspace to the repository. The owner will be automatically filled with the current user
     * @param {Workspace} workspace The Workspace to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacePost(workspace: Workspace, options?: any) {
        return RestApiFp(this.configuration).workspacePost(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a WorkspaceResource.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdDelete(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to retrieve a WorkspaceResource.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdGet(id: number, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the WorkspaceResource.
     * @param {number} id 
     * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourceIdPut(id: number, workspaceResource: WorkspaceResource, options?: any) {
        return RestApiFp(this.configuration).workspaceresourceIdPut(id, workspaceResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to save a WorkspaceResource to the repository.
     * @param {WorkspaceResource} workspaceResource The WorkspaceResource to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspaceresourcePost(workspaceResource: WorkspaceResource, options?: any) {
        return RestApiFp(this.configuration).workspaceresourcePost(workspaceResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds and image to the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {any} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllerWorkspaceAddimage(id: number, image?: any, options?: any) {
        return RestApiFp(this.configuration).workspacesControllerWorkspaceAddimage(id, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workspace Image from the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {number} imageId Workspace Image Id to be deleted from the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllerWorkspaceDelimage(id: number, imageId: number, options?: any) {
        return RestApiFp(this.configuration).workspacesControllerWorkspaceDelimage(id, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to register a WorkspaceResource open action. The WorkspaceResource timestamp last open will be updated
     * @param {number} id WorkspaceResource ID of the WorkspaceResource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllerWorkspaceResourceOpen(id: number, options?: any) {
        return RestApiFp(this.configuration).workspacesControllerWorkspaceResourceOpen(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the thumbnail of the workspace.
     * @param {number} id Workspace ID of the workspace
     * @param {any} [thumbNail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestApi
     */
    public workspacesControllerWorkspaceSetthumbnail(id: number, thumbNail?: any, options?: any) {
        return RestApiFp(this.configuration).workspacesControllerWorkspaceSetthumbnail(id, thumbNail, options).then((request) => request(this.axios, this.basePath));
    }

}


