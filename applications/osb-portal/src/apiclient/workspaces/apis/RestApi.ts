/* tslint:disable */
/* eslint-disable */
/**
 * Workspaces manager API
 * MetaCell Cloudharness Platform - Reference Workspaces manager API
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: mnp@metacell.us
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    FigshareRepository,
    FigshareRepositoryFromJSON,
    FigshareRepositoryToJSON,
    GITRepository,
    GITRepositoryFromJSON,
    GITRepositoryToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse2004,
    InlineResponse2004FromJSON,
    InlineResponse2004ToJSON,
    OSBRepository,
    OSBRepositoryFromJSON,
    OSBRepositoryToJSON,
    VolumeStorage,
    VolumeStorageFromJSON,
    VolumeStorageToJSON,
    Workspace,
    WorkspaceFromJSON,
    WorkspaceToJSON,
} from '../models';

export interface FigsharerepositoryGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface FigsharerepositoryIdDeleteRequest {
    id: number;
}

export interface FigsharerepositoryIdGetRequest {
    id: number;
}

export interface FigsharerepositoryIdPutRequest {
    id: number;
    figshareRepository: FigshareRepository;
}

export interface FigsharerepositoryPostRequest {
    figshareRepository: FigshareRepository;
}

export interface GitrepositoryGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface GitrepositoryIdDeleteRequest {
    id: number;
}

export interface GitrepositoryIdGetRequest {
    id: number;
}

export interface GitrepositoryIdPutRequest {
    id: number;
    gITRepository: GITRepository;
}

export interface GitrepositoryPostRequest {
    gITRepository: GITRepository;
}

export interface OsbrepositoryGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface OsbrepositoryIdDeleteRequest {
    id: number;
}

export interface OsbrepositoryIdGetRequest {
    id: number;
}

export interface OsbrepositoryIdPutRequest {
    id: number;
    oSBRepository: OSBRepository;
}

export interface OsbrepositoryPostRequest {
    oSBRepository: OSBRepository;
}

export interface VolumestorageGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface VolumestorageIdDeleteRequest {
    id: number;
}

export interface VolumestorageIdGetRequest {
    id: number;
}

export interface VolumestorageIdPutRequest {
    id: number;
    volumeStorage: VolumeStorage;
}

export interface VolumestoragePostRequest {
    volumeStorage: VolumeStorage;
}

export interface WorkspaceGetRequest {
    page?: number;
    perPage?: number;
    q?: string;
}

export interface WorkspaceIdDeleteRequest {
    id: number;
}

export interface WorkspaceIdGetRequest {
    id: number;
}

export interface WorkspaceIdPutRequest {
    id: number;
    workspace: Workspace;
}

export interface WorkspacePostRequest {
    workspace: Workspace;
}

/**
 * no description
 */
export class RestApi extends runtime.BaseAPI {

    /**
     * Used to list all available figsharerepositories.
     */
    async figsharerepositoryGetRaw(requestParameters: FigsharerepositoryGetRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/figsharerepository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * Used to list all available figsharerepositories.
     */
    async figsharerepositoryGet(requestParameters: FigsharerepositoryGetRequest): Promise<InlineResponse2003> {
        const response = await this.figsharerepositoryGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an figsharerepository from the repository.
     */
    async figsharerepositoryIdDeleteRaw(requestParameters: FigsharerepositoryIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an figsharerepository from the repository.
     */
    async figsharerepositoryIdDelete(requestParameters: FigsharerepositoryIdDeleteRequest): Promise<void> {
        await this.figsharerepositoryIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an figsharerepository from the repository.
     */
    async figsharerepositoryIdGetRaw(requestParameters: FigsharerepositoryIdGetRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an figsharerepository from the repository.
     */
    async figsharerepositoryIdGet(requestParameters: FigsharerepositoryIdGetRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an figsharerepository in the repository.
     */
    async figsharerepositoryIdPutRaw(requestParameters: FigsharerepositoryIdPutRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling figsharerepositoryIdPut.');
        }

        if (requestParameters.figshareRepository === null || requestParameters.figshareRepository === undefined) {
            throw new runtime.RequiredError('figshareRepository','Required parameter requestParameters.figshareRepository was null or undefined when calling figsharerepositoryIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FigshareRepositoryToJSON(requestParameters.figshareRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Update an figsharerepository in the repository.
     */
    async figsharerepositoryIdPut(requestParameters: FigsharerepositoryIdPutRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
     */
    async figsharerepositoryPostRaw(requestParameters: FigsharerepositoryPostRequest): Promise<runtime.ApiResponse<FigshareRepository>> {
        if (requestParameters.figshareRepository === null || requestParameters.figshareRepository === undefined) {
            throw new runtime.RequiredError('figshareRepository','Required parameter requestParameters.figshareRepository was null or undefined when calling figsharerepositoryPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/figsharerepository`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FigshareRepositoryToJSON(requestParameters.figshareRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FigshareRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to save a FigshareRepository to the repository. The owner will be automatically filled with the current user
     */
    async figsharerepositoryPost(requestParameters: FigsharerepositoryPostRequest): Promise<FigshareRepository> {
        const response = await this.figsharerepositoryPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available gitrepositories.
     */
    async gitrepositoryGetRaw(requestParameters: GitrepositoryGetRequest): Promise<runtime.ApiResponse<InlineResponse2002>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gitrepository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * Used to list all available gitrepositories.
     */
    async gitrepositoryGet(requestParameters: GitrepositoryGetRequest): Promise<InlineResponse2002> {
        const response = await this.gitrepositoryGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an gitrepository from the repository.
     */
    async gitrepositoryIdDeleteRaw(requestParameters: GitrepositoryIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an gitrepository from the repository.
     */
    async gitrepositoryIdDelete(requestParameters: GitrepositoryIdDeleteRequest): Promise<void> {
        await this.gitrepositoryIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an gitrepository from the repository.
     */
    async gitrepositoryIdGetRaw(requestParameters: GitrepositoryIdGetRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an gitrepository from the repository.
     */
    async gitrepositoryIdGet(requestParameters: GitrepositoryIdGetRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an gitrepository in the repository.
     */
    async gitrepositoryIdPutRaw(requestParameters: GitrepositoryIdPutRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling gitrepositoryIdPut.');
        }

        if (requestParameters.gITRepository === null || requestParameters.gITRepository === undefined) {
            throw new runtime.RequiredError('gITRepository','Required parameter requestParameters.gITRepository was null or undefined when calling gitrepositoryIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/gitrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: GITRepositoryToJSON(requestParameters.gITRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Update an gitrepository in the repository.
     */
    async gitrepositoryIdPut(requestParameters: GitrepositoryIdPutRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
     */
    async gitrepositoryPostRaw(requestParameters: GitrepositoryPostRequest): Promise<runtime.ApiResponse<GITRepository>> {
        if (requestParameters.gITRepository === null || requestParameters.gITRepository === undefined) {
            throw new runtime.RequiredError('gITRepository','Required parameter requestParameters.gITRepository was null or undefined when calling gitrepositoryPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/gitrepository`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GITRepositoryToJSON(requestParameters.gITRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GITRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to save a GITRepository to the repository. The owner will be automatically filled with the current user
     */
    async gitrepositoryPost(requestParameters: GitrepositoryPostRequest): Promise<GITRepository> {
        const response = await this.gitrepositoryPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available osbrepositories.
     */
    async osbrepositoryGetRaw(requestParameters: OsbrepositoryGetRequest): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/osbrepository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Used to list all available osbrepositories.
     */
    async osbrepositoryGet(requestParameters: OsbrepositoryGetRequest): Promise<InlineResponse2001> {
        const response = await this.osbrepositoryGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an osbrepository from the repository.
     */
    async osbrepositoryIdDeleteRaw(requestParameters: OsbrepositoryIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling osbrepositoryIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/osbrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an osbrepository from the repository.
     */
    async osbrepositoryIdDelete(requestParameters: OsbrepositoryIdDeleteRequest): Promise<void> {
        await this.osbrepositoryIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an osbrepository from the repository.
     */
    async osbrepositoryIdGetRaw(requestParameters: OsbrepositoryIdGetRequest): Promise<runtime.ApiResponse<OSBRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling osbrepositoryIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/osbrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OSBRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an osbrepository from the repository.
     */
    async osbrepositoryIdGet(requestParameters: OsbrepositoryIdGetRequest): Promise<OSBRepository> {
        const response = await this.osbrepositoryIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an osbrepository in the repository.
     */
    async osbrepositoryIdPutRaw(requestParameters: OsbrepositoryIdPutRequest): Promise<runtime.ApiResponse<OSBRepository>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling osbrepositoryIdPut.');
        }

        if (requestParameters.oSBRepository === null || requestParameters.oSBRepository === undefined) {
            throw new runtime.RequiredError('oSBRepository','Required parameter requestParameters.oSBRepository was null or undefined when calling osbrepositoryIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/osbrepository/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OSBRepositoryToJSON(requestParameters.oSBRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OSBRepositoryFromJSON(jsonValue));
    }

    /**
     * Update an osbrepository in the repository.
     */
    async osbrepositoryIdPut(requestParameters: OsbrepositoryIdPutRequest): Promise<OSBRepository> {
        const response = await this.osbrepositoryIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
     */
    async osbrepositoryPostRaw(requestParameters: OsbrepositoryPostRequest): Promise<runtime.ApiResponse<OSBRepository>> {
        if (requestParameters.oSBRepository === null || requestParameters.oSBRepository === undefined) {
            throw new runtime.RequiredError('oSBRepository','Required parameter requestParameters.oSBRepository was null or undefined when calling osbrepositoryPost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/osbrepository`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OSBRepositoryToJSON(requestParameters.oSBRepository),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OSBRepositoryFromJSON(jsonValue));
    }

    /**
     * Used to save a OSBRepository to the repository. The owner will be automatically filled with the current user
     */
    async osbrepositoryPost(requestParameters: OsbrepositoryPostRequest): Promise<OSBRepository> {
        const response = await this.osbrepositoryPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available volumestorages.
     */
    async volumestorageGetRaw(requestParameters: VolumestorageGetRequest): Promise<runtime.ApiResponse<InlineResponse2004>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2004FromJSON(jsonValue));
    }

    /**
     * Used to list all available volumestorages.
     */
    async volumestorageGet(requestParameters: VolumestorageGetRequest): Promise<InlineResponse2004> {
        const response = await this.volumestorageGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an volumestorage from the repository.
     */
    async volumestorageIdDeleteRaw(requestParameters: VolumestorageIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an volumestorage from the repository.
     */
    async volumestorageIdDelete(requestParameters: VolumestorageIdDeleteRequest): Promise<void> {
        await this.volumestorageIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve an volumestorage from the repository.
     */
    async volumestorageIdGetRaw(requestParameters: VolumestorageIdGetRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Used to retrieve an volumestorage from the repository.
     */
    async volumestorageIdGet(requestParameters: VolumestorageIdGetRequest): Promise<VolumeStorage> {
        const response = await this.volumestorageIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an volumestorage in the repository.
     */
    async volumestorageIdPutRaw(requestParameters: VolumestorageIdPutRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling volumestorageIdPut.');
        }

        if (requestParameters.volumeStorage === null || requestParameters.volumeStorage === undefined) {
            throw new runtime.RequiredError('volumeStorage','Required parameter requestParameters.volumeStorage was null or undefined when calling volumestorageIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: VolumeStorageToJSON(requestParameters.volumeStorage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Update an volumestorage in the repository.
     */
    async volumestorageIdPut(requestParameters: VolumestorageIdPutRequest): Promise<VolumeStorage> {
        const response = await this.volumestorageIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
     */
    async volumestoragePostRaw(requestParameters: VolumestoragePostRequest): Promise<runtime.ApiResponse<VolumeStorage>> {
        if (requestParameters.volumeStorage === null || requestParameters.volumeStorage === undefined) {
            throw new runtime.RequiredError('volumeStorage','Required parameter requestParameters.volumeStorage was null or undefined when calling volumestoragePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/volumestorage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VolumeStorageToJSON(requestParameters.volumeStorage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VolumeStorageFromJSON(jsonValue));
    }

    /**
     * Used to save a VolumeStorage to the repository. The owner will be automatically filled with the current user
     */
    async volumestoragePost(requestParameters: VolumestoragePostRequest): Promise<VolumeStorage> {
        const response = await this.volumestoragePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to list all available workspaces.
     */
    async workspaceGetRaw(requestParameters: WorkspaceGetRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.perPage !== undefined) {
            queryParameters['per_page'] = requestParameters.perPage;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Used to list all available workspaces.
     */
    async workspaceGet(requestParameters: WorkspaceGetRequest): Promise<InlineResponse200> {
        const response = await this.workspaceGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an workspace from the repository.
     */
    async workspaceIdDeleteRaw(requestParameters: WorkspaceIdDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an workspace from the repository.
     */
    async workspaceIdDelete(requestParameters: WorkspaceIdDeleteRequest): Promise<void> {
        await this.workspaceIdDeleteRaw(requestParameters);
    }

    /**
     * Used to retrieve a workspace from the repository.
     */
    async workspaceIdGetRaw(requestParameters: WorkspaceIdGetRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Used to retrieve a workspace from the repository.
     */
    async workspaceIdGet(requestParameters: WorkspaceIdGetRequest): Promise<Workspace> {
        const response = await this.workspaceIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an workspace in the repository.
     */
    async workspaceIdPutRaw(requestParameters: WorkspaceIdPutRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling workspaceIdPut.');
        }

        if (requestParameters.workspace === null || requestParameters.workspace === undefined) {
            throw new runtime.RequiredError('workspace','Required parameter requestParameters.workspace was null or undefined when calling workspaceIdPut.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceToJSON(requestParameters.workspace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Update an workspace in the repository.
     */
    async workspaceIdPut(requestParameters: WorkspaceIdPutRequest): Promise<Workspace> {
        const response = await this.workspaceIdPutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Used to save a Workspace to the repository. The owner will be automatically filled with the current user
     */
    async workspacePostRaw(requestParameters: WorkspacePostRequest): Promise<runtime.ApiResponse<Workspace>> {
        if (requestParameters.workspace === null || requestParameters.workspace === undefined) {
            throw new runtime.RequiredError('workspace','Required parameter requestParameters.workspace was null or undefined when calling workspacePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("bearerAuth", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/workspace`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkspaceToJSON(requestParameters.workspace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkspaceFromJSON(jsonValue));
    }

    /**
     * Used to save a Workspace to the repository. The owner will be automatically filled with the current user
     */
    async workspacePost(requestParameters: WorkspacePostRequest): Promise<Workspace> {
        const response = await this.workspacePostRaw(requestParameters);
        return await response.value();
    }

}
